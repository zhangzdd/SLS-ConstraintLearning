% YALMIP-based Control Contraction Metric (CCM) synthesis
clear; clc;
yalmip('clear');

% System dynamics
% Double integrator dynamics
Ts = 1;
A = [0 0 1 0;0 0 0 1; 0 0 0 0; 0 0 0 0]*Ts+ eye(4);
% B_t = [1/2*Ts^2 0;0 1/2*Ts^2;Ts 0;0 Ts]; 
% Omit the second order terms
B = [0 0;0 0;1 0;0 1]*Ts;
n = size(A, 1);

% Decision variables
W = sdpvar(n, n, 'symmetric');  % W = M^{-1}
rho = sdpvar(1);                % scalar multiplier
lambda = 0.5;                   % contraction rate

% LMI condition (from Finsler-transformed CCM inequality)
LMI = A*W + W*A' - rho*(B*B') + 2*lambda*W;

% Constraints
% constraints = [W >= 1e-3*eye(n), rho >= 1e-3, LMI <= -1e-6*eye(n)];
constraints = [W >= 1e-5*eye(n), rho >= 1e-5, LMI <= -1e-5*eye(n)];

% Solve
options = sdpsettings('solver', 'sdpt3', 'verbose', 1);
sol = optimize(constraints, [], options);

% Check and display
if sol.problem == 0
    Wsol = value(W);
    disp('Feasible CCM found:');
    disp('W ='); disp(Wsol);
    disp('M = inv(W) ='); disp(inv(Wsol));
else
    disp('No feasible solution found.');
    disp(sol.info);
end

% ========================== Multi-Trajectory Simulation ==========================
% if sol.problem == 0
%     A = [0 1; -2 -3];
%     M = inv(value(W));
%     lambda = 0.5;
% 
%     % Base initial condition
%     x0 = [1; 1];
% 
%     % Create multiple perturbed initial conditions
%     num_trajectories = 6;
%     angles = linspace(0, 2*pi, num_trajectories+1);
%     angles(end) = [];
%     radius = 0.1;
%     initial_conditions = x0 + radius * [cos(angles); sin(angles)];
% 
%     % Simulation settings
%     T = 5;
%     dt = 0.01;
%     time = 0:dt:T;
%     N = length(time);
% 
%     figure;
%     hold on;
%     colors = lines(num_trajectories);
% 
%     for i = 1:num_trajectories
%         xi = initial_conditions(:, i);
%         traj = zeros(2, N);
%         traj(:,1) = xi;
% 
%         for k = 1:N-1
%             traj(:,k+1) = traj(:,k) + dt * A * traj(:,k);
%         end
% 
%         % Plot trajectory
%         plot(traj(1,:), traj(2,:), 'Color', colors(i,:), 'LineWidth', 2);
% 
%         % Start and end markers
%         plot(traj(1,1), traj(2,1), 'o', 'MarkerSize', 6, ...
%              'MarkerFaceColor', colors(i,:), 'Color', 'k');  % Start
%         plot(traj(1,end), traj(2,end), '*', 'MarkerSize', 8, ...
%              'Color', colors(i,:));  % End
%     end
% 
%     title('Contraction of Multiple Trajectories');
%     xlabel('x_1'); ylabel('x_2');
%     axis equal; grid on;
%     legend('Trajectories', 'Location', 'best');
% end

% ========== If Feasible, Proceed ==========
if sol.problem == 0
    Wsol = value(W);
    rhosol = value(rho);
    M = inv(Wsol);

    % Compute feedback gain
    K = -(1/2*rhosol) * B' * M;  % 1Ã—2 gain
    disp('CCM gain K ='); disp(K);

    % Define closed-loop dynamics
    A_cl = A + B*K;

    % Simulation settings
    T = 5;
    dt = 0.01;
    time = 0:dt:T;
    N = length(time);

    % Generate multiple initial conditions
    x0 = [1; 1];
    num_traj = 6;
    radius = 0.1;
    angles = linspace(0, 2*pi, num_traj+1); angles(end) = [];
    x0s = x0 + radius * [cos(angles); sin(angles)];

    % Simulate all trajectories
    figure; hold on;
    colors = lines(num_traj);
    for i = 1:num_traj
        x = zeros(2,N);
        x(:,1) = x0s(:,i);
        for k = 1:N-1
            x(:,k+1) = x(:,k) + dt * A_cl * x(:,k);  % Closed-loop
        end
        plot(x(1,:), x(2,:), 'Color', colors(i,:), 'LineWidth', 2);
        plot(x(1,1), x(2,1), 'o', 'MarkerSize', 6, ...
             'MarkerFaceColor', colors(i,:), 'Color', 'k');  % start
        plot(x(1,end), x(2,end), '*', 'MarkerSize', 8, ...
             'Color', colors(i,:));  % end
    end

    title('Controlled Trajectories under u = Kx (CCM)');
    xlabel('x_1'); ylabel('x_2'); axis equal; grid on;

else
    error('No feasible CCM found: %s', sol.info);
end

% ========== Compare Two Trajectories ==========
% Choose nominal and perturbed initial conditions
x1_0 = x0;
delta0 = [0.05; -0.05];
x2_0 = x1_0 + delta0;

x1 = zeros(2,N);
x2 = zeros(2,N);
x1(:,1) = x1_0;
x2(:,1) = x2_0;

dM = zeros(1,N);

for k = 1:N-1
    x1(:,k+1) = x1(:,k) + dt * A_cl * x1(:,k);
    x2(:,k+1) = x2(:,k) + dt * A_cl * x2(:,k);
    delta = x2(:,k) - x1(:,k);
    dM(k) = sqrt(delta' * M * delta);
end
delta = x2(:,N) - x1(:,N);
dM(N) = sqrt(delta' * M * delta);

% ========== Plot Metric Distance ==========
figure;
plot(time, dM, 'k', 'LineWidth', 2); hold on;
plot(time, dM(1)*exp(-lambda*time), 'r--', 'LineWidth', 1.5);
legend('||\delta(t)||_M', 'Exponential bound');
title('Contraction of Distance in CCM Metric');
xlabel('Time'); ylabel('Riemannian Distance');
grid on;

% ======== Target Tracking Simulation =========
% Reference (target) trajectory
x_star0 = [1; 1];
x_star = zeros(2,N);
x_star(:,1) = x_star0;

for k = 1:N-1
    x_star(:,k+1) = x_star(:,k) + dt * A_cl * x_star(:,k);  % Nominal traj
end

% Perturbed initial condition (actual trajectory)
x_actual = zeros(2,N);
x_actual(:,1) = x_star0 + [0.2; -0.2];  % deviation from target

for k = 1:N-1
    x_actual(:,k+1) = x_actual(:,k) + dt * A_cl * x_actual(:,k);  % same control law
end

% ======== Plot target and actual traj ========
figure;
plot(x_star(1,:), x_star(2,:), 'k--', 'LineWidth', 2); hold on;
plot(x_actual(1,:), x_actual(2,:), 'b', 'LineWidth', 2);
plot(x_star(1,1), x_star(2,1), 'ko', 'MarkerFaceColor', 'k');
plot(x_actual(1,1), x_actual(2,1), 'bo', 'MarkerFaceColor', 'b');
legend('Target x^*(t)', 'Actual x(t)');
title('CCM Tracking of Target Trajectory');
xlabel('x_1'); ylabel('x_2'); axis equal; grid on;

% ======== Plot tracking error ||x - x^*|| ========
e_norm = vecnorm(x_actual - x_star);
figure;
plot(time, e_norm, 'r', 'LineWidth', 2); hold on;
plot(time, e_norm(1)*exp(-lambda*time), 'k--', 'LineWidth', 1.5);
legend('||x(t) - x^*(t)||', 'Exponential bound');
xlabel('Time'); ylabel('Tracking Error Norm');
title('Tracking Error under CCM Controller');
grid on;

